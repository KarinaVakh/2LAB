#include <iostream>
#include <conio.h>

using namespace std;

class Point {
protected:
    // меняем на privat protected
    // protected
    int x, y; // два атрибута
public:
    Point() {// констурктор
        printf("Point()\n");  // отладочный вывод для того чтобы видеть какой констурктор вызывается
        x = 0;
        y = 0; // начальные значения

    }
    Point(int x, int y) {// констурктор с параметрами
        printf("Point(int x, int y)\n");  // отладочный вывод для того чтобы видеть какой констурктор вызывается
        this->x = x;
        this->y = y; // начальные значения

    }
    Point(const Point& p) {// констурктор копирующий переносит все свойства из того обькта который передали
        printf("Point(const Point &p)\n");  // отладочный вывод для того чтобы видеть какой констурктор вызывается
        x = p.x;
        y = p.y; // начальные значения

    }
    ~Point() { // диструктор
        printf("%d, %d\n", x, y); // вывод текущего состояния обьекта чтобы видеть что в нем хранилось когда он удаляется
        printf("~Point()\n");
    }

    void move(int dx, int dy) // метод мув
    {
        x = x + dx; // меняет координаты
        y = y + dy;
    }

    void reset(); // без параметров и реализации
    
};

void Point::reset() { // после объявления класса мы моем написаь реализацию этого метода
    x = 0;
    y = 0;
}

class ColoredPoint :public Point {  // class потомок наследуется от поинта
protected:
    int color; // добавляет ему свойтво цвет

public:
    ColoredPoint() :Point() {// констурктор вызываем конструктор базовго класса
        printf("ColoredPointPoint()\n");  // отладочный вывод для того чтобы видеть какой констурктор вызывается
        color = 0; // заполняем жто поле
    }

    ColoredPoint(int x, int y, int color) :Point(x, y) {// констурктор с параметрами у калор поинт 3 парметра
        printf("ColoredPointPoint(int x, int y)\n");  // отладочный вывод для того чтобы видеть какой констурктор вызывается
        this->color = color;
        // начальные значения

    }
    ColoredPoint(const ColoredPoint& p) {// констурктор копирующий переносит все свойства из того обькта который передали  тут вручную скопируем все 3 поля
        printf("ColoredPointPoint(const Point &p)\n");  // отладочный вывод для того чтобы видеть какой констурктор вызывается
        color = p.color;
            x = p.x;
        y = p.y; // начальные значения

    }
    ~ColoredPoint() { // диструктор
        printf("%d, %d color=%d\n", x, y, color); // вывод текущего состояния обьекта чтобы видеть что в нем хранилось когда он удаляется   все парметры выведем
        printf("~ColoredPointPoint()\n");
    }
    void change_color(int new_color) // метод 
    {
        color = new_color;

    }
};


class Section {  // не насл от поинта
protected:
    Point* p1; //два указателя на первую и вторую точки орезка
    Point* p2;
public:
    Section() {// констурктор вызываем конструктор базовго класса
        printf("Section()\n");  // отладочный вывод для того чтобы видеть какой констурктор вызывается
        p1 = new Point; // при создании отрезка по умолчанию отрезок должен сам себе создать 2 точки
        p2 = new Point;// конструктор создаст две точки с нулевыми координатами
    }
    Section(int x1, int y1, int x2, int y2) {// констурктор с параметрами кот созд отрезок по координатам 2 точек
        printf("Section(int x1, int y1, int x2, int y2)\n");  // отладочный вывод для того чтобы видеть какой констурктор вызывается
        p1 = new Point(x1, y1);  //у точек уже есть конструкторы 
        p2 = new Point(x2, y2);
        // начальные значения
    }
    Section(const Section& p) {// констурктор копирующий переносит все свойства из того обькта который передали  тут вручную скопируем все 3 поля
        printf("Section(const Section &p)\n");  // отладочный вывод для того чтобы видеть какой констурктор вызывается
     //   p1 = s.p1; //нас просят созадть копию отрезка два пути в свои собвенные свойства п1 мы можем занести значения п1 из того отрезка котрый нам передали
       // p2 = s.p2;
        // второй вариант копирования мы дожны ввзят тот отрезок котрый нам передли и  его первую точку  и создать тчную копию этой точки путем вызова констр копировани точки (s - обьект, п1  указатель на поинт поэтому мы долдны его разыменрваь*()
        p1 = new Point(*(s.p1));
        p2 = new Point(*(s.p2));
    }
    ~Section() { // диструктор
        printf("%d, %d color=%d\n", x, y, color); // вывод текущего состояния обьекта чтобы видеть что в нем хранилось когда он удаляется   все парметры выведем
        delete p1;
        delete p2;
        printf("~Section()\n");
    }


};


int main(int arg, char* argv[])
{
    {
        Point p; // задаем обьекты статически
        Point p2(10, 20); // задаем обьекты статически
        Point p3(p2);    // (при выволе создастся 3 обьекта с помощью трез констуркторов (удалится 2. 3. 1 обьекты) (это были классы атрибуты конструкторы , уничтожение статтически созданных обьектов), создание статических обьектов
    }

    {
        Point* p = new Point; // указатели динамически обьекты
        Point* p2 = new Point(10, 20); // 
        Point* p3 = new Point(*p2);    // копирование требует от нас указатель мы разыменовываем его
        delete p;//  сами мы должны удалить чтобы увидеть работу диструктора, удаляются в порядке, в котором мы их удаляем 
        delete p2; // создание дин обьектоы создание обьектов с помощью констр , удаление дин обьектов
        delete p3;
    }

    // если методы сделать приватными p->x то нельзя будет потому что никаие свойтсва не будут доступны protected++ public p->x=5
// для мув
    {Point* p = new Point(1, 2); // обьект с заданными координатами

    p->reset();     //reset  // это были проверка доступности атр и метод, реализация методов сразу и после определения, реализации констр и дистр
    p->move(10, 10); // обратиться к ссвойтсвам мы не можем но вызвать метод можем
    delete p;
    // при удалении координаты точки совсем другие
    }

    // для подкласса // при создании обьекта кдаса калор пинт сначал запуск конструктор поинта потом калор потом он удаляется и диструктор калор поинта и дистрк поинта
    {
        ColoredPoint* p = new ColoredPoint(1, 2, 42);  //  какие дистр и констр вызываютмя 
        delete p;
    }


    {
        Point* p = new ColoredPoint(1, 2, 42);  //если у нас есть переменная указатель на базовый класс то мы модем помесить в нее обьект потомка
        delete p;

    }// создается обьект класса калр поинт , констуктор но вызывается дисруктор только базового классса ( чем грозит как бороться?)

    {
        Point* p1 = new ColoredPoint(1, 2, 42);    // если два варианта  1 обьект класа калр поинт и помещаю его в переменную своего собсвенного класа а в другом помещаю его в переменную класса предка , они работают
        ColoredPoint* p2 = new  ColoredPoint(1, 2, 42);
        delete p1;
        delete p2;
    }
    // для них по разному вызываются диструкторы обьекты создались удалился 1 и второй обьект 1 неправильн (1 только диструтктор) 2 правильн (оба дистр)
   // если обьект одного и того же класса помещать в переменную своего или базовго класа
    //если писать p1-> то мы модем обратиться только к move b reset
    //если p2->  то и + к чендж калар  p2-> и доступны переменные классов потомов
    // помещение обектов в переменные различных типов мы попробыали


    _getch();
    return 0;
    }



  //  { ColoredPoint* p = new Point(1, 2, 42);  //если у нас есть переменная указатель на базовый класс то мы модем помесить в нее обьект потомка
   // delete p;  // когда мы создам переменную базовго класса и внее пытаемся помесить переменнуб потомка, то у нас не компилирется нельзя

  //  Point* p = new Point(1, 2, 42); //если сначала сделать обьект класса поинт и потом в переменню поместиь пе то оьект он создает нормально но при попытке поместит его адрес в пееменную указател на адрес потомка он не модет это сделать потому что правила приведения типов так не работают

   // ColoredPoint* p2 = p}